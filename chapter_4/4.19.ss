;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Exercise 4.19.  Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are   ;;
;; arguing about the desired result of evaluating the expression          ;;
;;                                                                        ;;
;; (let ((a 1))                                                           ;;
;;   (define (f x)                                                        ;;
;;     (define b (+ a x))                                                 ;;
;;     (define a 5)                                                       ;;
;;     (+ a b))                                                           ;;
;;   (f 10))                                                              ;;
;;                                                                        ;;
;; Ben asserts that the result should be obtained using the sequential    ;;
;; rule for define: b is defined to be 11, then a is defined to be 5, so  ;;
;; the result is 16. Alyssa objects that mutual recursion requires the    ;;
;; simultaneous scope rule for internal procedure definitions, and that   ;;
;; it is unreasonable to treat procedure names differently from other     ;;
;; names. Thus, she argues for the mechanism implemented in exercise      ;;
;; 4.16. This would lead to a being unassigned at the time that the value ;;
;; for b is to be computed. Hence, in Alyssa's view the procedure should  ;;
;; produce an error. Eva has a third opinion. She says that if the        ;;
;; definitions of a and b are truly meant to be simultaneous, then the    ;;
;; value 5 for a should be used in evaluating b. Hence, in Eva's view a   ;;
;; should be 5, b should be 15, and the result should be 20. Which (if    ;;
;; any) of these viewpoints do you support? Can you devise a way to       ;;
;; implement internal definitions so that they behave as Eva prefers?26   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Eva's view looks correct, one quick thought for the implemention would      ;;
;; be to list out all defines from the procedure body and analyse their        ;;
;; dependencies                                                                ;;
;;                                                                             ;;
;; For eg, in the above example,                                               ;;
;;                                                                             ;;
;; b <- a                                                                      ;;
;; a <- ø/constant                                                             ;;
;;                                                                             ;;
;; Having found such list we would require sorting it out based on each's      ;;
;; dependencies. For above, we will have to move them around, like,            ;;
;;                                                                             ;;
;; a <- ø/constant                                                             ;;
;; b <- a                                                                      ;;
;;                                                                             ;;
;; However, this is a simple example, and in cases where one depends on        ;;
;; other, it would be impossible to proceed, to given an example,              ;;
;;                                                                             ;;
;; (define (f x)                                                               ;;
;;   (define x (+ 1 y))                                                        ;;
;;   (define y (+ 1 x))                                                        ;;
;;   (+ x y))                                                                  ;;
;; (f 10)                                                                      ;;
;;                                                                             ;;
;; The above will result into dependencies' that would look like -             ;;
;;                                                                             ;;
;; x <- y                                                                      ;;
;; y <- x                                                                      ;;
;;                                                                             ;;
;; The chicken/egg problem. Deadlock. In such cases we can return errors,      ;;
;; but still doing all this involves a lot of computation.                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
